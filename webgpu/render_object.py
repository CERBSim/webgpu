import uuid

from .camera import Camera
from .canvas import Canvas
from .light import Light
from .uniforms import ClippingUniforms
from .utils import BaseBinding, _is_pyodide, create_bind_group, get_device
from .webgpu_api import (
    CommandEncoder,
    CompareFunction,
    DepthStencilState,
    Device,
    FragmentState,
    PrimitiveState,
    PrimitiveTopology,
    VertexState,
)

_render_objects = {}


def _add_render_object(obj):
    if not _is_pyodide:
        _id = str(uuid.uuid4())
        _render_objects[_id] = obj
        obj._id = _id
    else:
        if not hasattr(obj, "_id"):
            return
        if obj._id in _render_objects and obj is not _render_objects[obj._id]:
            raise ValueError(f"Object with id {obj._id} already exists")
        _render_objects[obj._id] = obj


class _PostInitMeta(type):
    def __call__(cls, *args, **kw):
        instance = super().__call__(*args, **kw)
        _add_render_object(instance)
        return instance


class RedrawObject:
    _timestamp: float = -1

    def redraw(self, timestamp: float | None = None, **kwargs):
        if timestamp is None:
            import time

            timestamp = time.time()

        if timestamp == self._timestamp:
            return

        self._timestamp = timestamp
        import webgpu.jupyter as wj

        wj.update_render_object(self._id, **kwargs)

    def __setstate__(self, state):
        self.__dict__.update(state)
        if _is_pyodide:
            _render_objects[self._id] = self


class DataObject(RedrawObject):
    _buffers: dict = {}

    def _create_data(self):
        """Create the binary data for the GPU (either in pyodide or in the kernel)"""
        raise NotImplementedError

    def _create_buffers(self, device: Device) -> dict:
        """Copy data generated by create_data to the GPU"""
        return {}

    def needs_update(self) -> bool:
        return True

    def get_buffers(self, device: Device):
        if self.needs_update():
            self._buffers = {}
            self._create_data()

        if not self._buffers:
            self._buffers = self._create_buffers(device)

        return self._buffers


class RenderOptions:
    viewport: tuple[int, int, int, int, float, float]
    canvas: Canvas

    def __init__(self, canvas):
        self.canvas = canvas
        self.clipping = ClippingUniforms(self.device)
        self.light = Light(self.device)
        self.camera = Camera(self.device)

    @property
    def device(self) -> Device:
        return self.canvas.device

    def update_buffers(self):
        self.clipping.update_buffer()
        self.camera._update_uniforms()

    def get_bindings(self):
        return [
            *self.clipping.get_bindings(),
            *self.light.get_bindings(),
            *self.camera.get_bindings(),
        ]

    def begin_render_pass(self, command_encoder: CommandEncoder, **kwargs):
        load_op = command_encoder.getLoadOp()

        render_pass_encoder = command_encoder.beginRenderPass(
            self.canvas.color_attachments(load_op),
            self.canvas.depth_stencil_attachment(load_op),
            **kwargs,
        )

        render_pass_encoder.setViewport(
            0, 0, self.canvas.canvas.width, self.canvas.canvas.height, 0.0, 1.0
        )

        return render_pass_encoder


class BaseRenderObject(RedrawObject, metaclass=_PostInitMeta):
    options: RenderOptions
    label: str = ""

    def __init__(self, label=None):
        if label is None:
            self.label = self.__class__.__name__
        else:
            self.label = label

    def get_bounding_box(self):
        return ([0.0, 0.0, 0.0], [1.0, 1.0, 1.0])

    def update(self):
        self.create_render_pipeline()

    @property
    def device(self) -> Device:
        return get_device()

    @property
    def canvas(self) -> Canvas:
        return self.options.canvas

    def create_render_pipeline(self) -> None:
        raise NotImplementedError

    def render(self, encoder: CommandEncoder):
        raise NotImplementedError

    def get_bindings(self) -> list[BaseBinding]:
        raise NotImplementedError

    def get_shader_code(self) -> str:
        raise NotImplementedError


class RenderObject(BaseRenderObject):
    """Base class for render objects"""

    n_vertices: int = 0
    n_instances: int = 1
    topology: PrimitiveTopology = PrimitiveTopology.triangle_list
    depthBias: int = 0
    vertex_entry_point: str = "vertex_main"
    fragment_entry_point: str = "fragment_main"

    def create_render_pipeline(self) -> None:
        shader_module = self.device.createShaderModule(self.get_shader_code())
        layout, self.group = create_bind_group(self.device, self.get_bindings())
        self.pipeline = self.device.createRenderPipeline(
            self.device.createPipelineLayout([layout]),
            vertex=VertexState(
                module=shader_module, entryPoint=self.vertex_entry_point
            ),
            fragment=FragmentState(
                module=shader_module,
                entryPoint=self.fragment_entry_point,
                targets=[self.options.canvas.color_target],
            ),
            primitive=PrimitiveState(topology=self.topology),
            depthStencil=DepthStencilState(
                format=self.options.canvas.depth_format,
                depthWriteEnabled=True,
                depthCompare=CompareFunction.less,
                depthBias=self.depthBias,
            ),
            multisample=self.options.canvas.multisample,
        )

    def render(self, encoder: CommandEncoder) -> None:
        render_pass = self.options.begin_render_pass(encoder)
        render_pass.setPipeline(self.pipeline)
        render_pass.setBindGroup(0, self.group)
        render_pass.draw(self.n_vertices, self.n_instances)
        render_pass.end()
